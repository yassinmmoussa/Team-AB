"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

<<<<<<< HEAD
function _helperPluginUtils() {
  const data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function () {
    return data;
  };

  return data;
}

function _core() {
  const data = require("@babel/core");

  _core = function () {
    return data;
  };

  return data;
}

var _default = (0, _helperPluginUtils().declare)((api, options) => {
=======
var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _core = require("@babel/core");

var _default = (0, _helperPluginUtils.declare)((api, options) => {
>>>>>>> 0ae1a948acc774b725d2813ed0b826c52e048967
  api.assertVersion(7);
  const {
    loose
  } = options;
  let helperName = "taggedTemplateLiteral";
  if (loose) helperName += "Loose";

  function buildConcatCallExpressions(items) {
    let avail = true;
    return items.reduce(function (left, right) {
<<<<<<< HEAD
      let canBeInserted = _core().types.isLiteral(right);
=======
      let canBeInserted = _core.types.isLiteral(right);
>>>>>>> 0ae1a948acc774b725d2813ed0b826c52e048967

      if (!canBeInserted && avail) {
        canBeInserted = true;
        avail = false;
      }

<<<<<<< HEAD
      if (canBeInserted && _core().types.isCallExpression(left)) {
=======
      if (canBeInserted && _core.types.isCallExpression(left)) {
>>>>>>> 0ae1a948acc774b725d2813ed0b826c52e048967
        left.arguments.push(right);
        return left;
      }

<<<<<<< HEAD
      return _core().types.callExpression(_core().types.memberExpression(left, _core().types.identifier("concat")), [right]);
=======
      return _core.types.callExpression(_core.types.memberExpression(left, _core.types.identifier("concat")), [right]);
>>>>>>> 0ae1a948acc774b725d2813ed0b826c52e048967
    });
  }

  return {
    name: "transform-template-literals",
    visitor: {
      TaggedTemplateExpression(path) {
        const {
          node
        } = path;
        const {
          quasi
        } = node;
        const strings = [];
        const raws = [];
        let isStringsRawEqual = true;

        for (const elem of quasi.quasis) {
          const {
            raw,
            cooked
          } = elem.value;
<<<<<<< HEAD
          const value = cooked == null ? path.scope.buildUndefinedNode() : _core().types.stringLiteral(cooked);
          strings.push(value);
          raws.push(_core().types.stringLiteral(raw));
=======
          const value = cooked == null ? path.scope.buildUndefinedNode() : _core.types.stringLiteral(cooked);
          strings.push(value);
          raws.push(_core.types.stringLiteral(raw));
>>>>>>> 0ae1a948acc774b725d2813ed0b826c52e048967

          if (raw !== cooked) {
            isStringsRawEqual = false;
          }
        }

        const scope = path.scope.getProgramParent();
        const templateObject = scope.generateUidIdentifier("templateObject");
        const helperId = this.addHelper(helperName);
<<<<<<< HEAD
        const callExpressionInput = [_core().types.arrayExpression(strings)];

        if (!isStringsRawEqual) {
          callExpressionInput.push(_core().types.arrayExpression(raws));
        }

        const lazyLoad = _core().template.ast`
          function ${templateObject}() {
            const data = ${_core().types.callExpression(helperId, callExpressionInput)};
=======
        const callExpressionInput = [_core.types.arrayExpression(strings)];

        if (!isStringsRawEqual) {
          callExpressionInput.push(_core.types.arrayExpression(raws));
        }

        const lazyLoad = _core.template.ast`
          function ${templateObject}() {
            const data = ${_core.types.callExpression(helperId, callExpressionInput)};
>>>>>>> 0ae1a948acc774b725d2813ed0b826c52e048967
            ${templateObject} = function() { return data };
            return data;
          } 
        `;
        scope.path.unshiftContainer("body", lazyLoad);
<<<<<<< HEAD
        path.replaceWith(_core().types.callExpression(node.tag, [_core().types.callExpression(_core().types.cloneNode(templateObject), []), ...quasi.expressions]));
=======
        path.replaceWith(_core.types.callExpression(node.tag, [_core.types.callExpression(_core.types.cloneNode(templateObject), []), ...quasi.expressions]));
>>>>>>> 0ae1a948acc774b725d2813ed0b826c52e048967
      },

      TemplateLiteral(path) {
        const nodes = [];
        const expressions = path.get("expressions");
        let index = 0;

        for (const elem of path.node.quasis) {
          if (elem.value.cooked) {
<<<<<<< HEAD
            nodes.push(_core().types.stringLiteral(elem.value.cooked));
=======
            nodes.push(_core.types.stringLiteral(elem.value.cooked));
>>>>>>> 0ae1a948acc774b725d2813ed0b826c52e048967
          }

          if (index < expressions.length) {
            const expr = expressions[index++];
            const node = expr.node;

<<<<<<< HEAD
            if (!_core().types.isStringLiteral(node, {
=======
            if (!_core.types.isStringLiteral(node, {
>>>>>>> 0ae1a948acc774b725d2813ed0b826c52e048967
              value: ""
            })) {
              nodes.push(node);
            }
          }
        }

<<<<<<< HEAD
        const considerSecondNode = !loose || !_core().types.isStringLiteral(nodes[1]);

        if (!_core().types.isStringLiteral(nodes[0]) && considerSecondNode) {
          nodes.unshift(_core().types.stringLiteral(""));
=======
        const considerSecondNode = !loose || !_core.types.isStringLiteral(nodes[1]);

        if (!_core.types.isStringLiteral(nodes[0]) && considerSecondNode) {
          nodes.unshift(_core.types.stringLiteral(""));
>>>>>>> 0ae1a948acc774b725d2813ed0b826c52e048967
        }

        let root = nodes[0];

        if (loose) {
          for (let i = 1; i < nodes.length; i++) {
<<<<<<< HEAD
            root = _core().types.binaryExpression("+", root, nodes[i]);
=======
            root = _core.types.binaryExpression("+", root, nodes[i]);
>>>>>>> 0ae1a948acc774b725d2813ed0b826c52e048967
          }
        } else if (nodes.length > 1) {
          root = buildConcatCallExpressions(nodes);
        }

        path.replaceWith(root);
      }

    }
  };
});

exports.default = _default;